use rusnmp::ber::Asn1Tag;
use rusnmp::snmp::message::parse_message;
use rusnmp::snmp::pdu::ErrorStatus;
use rusnmp::snmp::pdu::ObjectSyntax;

const RAW_PACKET: &[u8] = &[
    0x30, 0x29, 0x02, 0x01, 0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa0, 0x1c, 0x02,
    0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x0e, 0x30, 0x0c, 0x06,
    0x08, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x05, 0x00,
];

#[test]
fn test_parse_v2c_get_request() {
    let message = parse_message(RAW_PACKET).unwrap();

    assert_eq!(message.version, 1);
    assert_eq!(message.community, b"public");

    let pdu = message.pdu;
    assert_eq!(pdu.tag, Asn1Tag::GetRequest);
    assert_eq!(pdu.request_id, 1);
    assert_eq!(pdu.error_status, ErrorStatus::NoError);
    assert_eq!(pdu.error_index, 0);

    assert_eq!(pdu.varbinds.len(), 1);

    let varbind = &pdu.varbinds[0];
    let expected_oid: Vec<u32> = vec![1, 3, 6, 1, 2, 1, 1, 1, 0];
    assert_eq!(varbind.oid, expected_oid);

    assert_eq!(varbind.value, ObjectSyntax::Null);
}

const RAW_PACKET_RESPONSE: &[u8] = &[
    0x30, 0x42, 0x02, 0x01, 0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa2, 0x35, 0x02,
    0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x27, 0x30, 0x25, 0x06,
    0x08, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x04, 0x19, 0x53, 0x61, 0x6d, 0x70, 0x6c,
    0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
    0x74, 0x69, 0x6f, 0x6e,
];

#[test]
fn test_parse_v2c_get_response() {
    let message = parse_message(RAW_PACKET_RESPONSE).unwrap();

    assert_eq!(message.version, 1);
    assert_eq!(message.community, b"public");

    let pdu = message.pdu;
    assert_eq!(pdu.tag, Asn1Tag::GetResponse);
    assert_eq!(pdu.request_id, 1);
    assert_eq!(pdu.error_status, ErrorStatus::NoError);
    assert_eq!(pdu.error_index, 0);

    assert_eq!(pdu.varbinds.len(), 1);

    let varbind = &pdu.varbinds[0];
    let expected_oid: Vec<u32> = vec![1, 3, 6, 1, 2, 1, 1, 1, 0];
    assert_eq!(varbind.oid, expected_oid);

    let expected_value = b"Sample system description";
    match &varbind.value {
        ObjectSyntax::OctetString(val) => {
            assert_eq!(val, expected_value);
        }
        _ => panic!("Expected OctetString, got {:?}", varbind.value),
    }
}

#[test]
fn test_parse_real_snmpd_response() {
    // Full packet capture including Ethernet/IP/UDP headers
    let full_packet = &[
        0x2, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0xe2, 0xed, 0xe8, 0x0, 0x0, 0x40, 0x11, 0x0, 0x0, 0x7f,
        0x0, 0x0, 0x1, 0x7f, 0x0, 0x0, 0x1, 0x0, 0xa1, 0xfc, 0x86, 0x0, 0xce, 0xfe, 0xe1,
        0x30, // <- starts at 30 -> SEQ
        0x81, 0xc3, 0x2, 0x1, 0x1, 0x4, 0x6, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa2, 0x81, 0xb5,
        0x2, 0x4, 0x18, 0xec, 0xdb, 0x43, 0x2, 0x1, 0x0, 0x2, 0x1, 0x0, 0x30, 0x81, 0xa6, 0x30,
        0x81, 0xa3, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x2, 0x1, 0x1, 0x1, 0x0, 0x4, 0x81, 0x96, 0x44, 0x61,
        0x72, 0x77, 0x69, 0x6e, 0x20, 0x4e, 0x61, 0x72, 0x65, 0x6e, 0x64, 0x72, 0x61, 0x73, 0x2d,
        0x4d, 0x61, 0x63, 0x42, 0x6f, 0x6f, 0x6b, 0x2d, 0x41, 0x69, 0x72, 0x2e, 0x6c, 0x6f, 0x63,
        0x61, 0x6c, 0x20, 0x32, 0x35, 0x2e, 0x30, 0x2e, 0x30, 0x20, 0x44, 0x61, 0x72, 0x77, 0x69,
        0x6e, 0x20, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,
        0x6e, 0x20, 0x32, 0x35, 0x2e, 0x30, 0x2e, 0x30, 0x3a, 0x20, 0x57, 0x65, 0x64, 0x20, 0x53,
        0x65, 0x70, 0x20, 0x31, 0x37, 0x20, 0x32, 0x31, 0x3a, 0x34, 0x31, 0x3a, 0x33, 0x39, 0x20,
        0x50, 0x44, 0x54, 0x20, 0x32, 0x30, 0x32, 0x35, 0x3b, 0x20, 0x72, 0x6f, 0x6f, 0x74, 0x3a,
        0x78, 0x6e, 0x75, 0x2d, 0x31, 0x32, 0x33, 0x37, 0x37, 0x2e, 0x31, 0x2e, 0x39, 0x7e, 0x31,
        0x34, 0x31, 0x2f, 0x52, 0x45, 0x4c, 0x45, 0x41, 0x53, 0x45, 0x5f, 0x41, 0x52, 0x4d, 0x36,
        0x34, 0x5f, 0x54, 0x38, 0x31, 0x30, 0x33, 0x20, 0x61, 0x72, 0x6d, 0x36, 0x34,
    ];

    // SNMP data starts at offset 32 (after pcap + IP + UDP headers)
    // The SNMP message begins with 0x30 (Sequence tag)
    let snmp_offset = 32;
    let snmp_data = &full_packet[snmp_offset..];

    let msg = parse_message(snmp_data).expect("Failed to parse");

    println!("Version: {}", msg.version);
    println!("Community: {}", String::from_utf8_lossy(&msg.community));
    println!("PDU type: {:?}", msg.pdu.tag);
    println!("VarBinds: {}", msg.pdu.varbinds.len());
}
