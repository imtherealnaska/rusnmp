use rusnmp::ber::Asn1Tag;
use rusnmp::snmp::message::parse_message;
use rusnmp::snmp::message::SnmpMessage;
use rusnmp::snmp::pdu::ErrorStatus;
use rusnmp::snmp::pdu::ObjectSyntax;
use rusnmp::snmp::pdu::Pdu;
use rusnmp::snmp::pdu::VarBind;

const RAW_PACKET: &[u8] = &[
    0x30, 0x29, 0x02, 0x01, 0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa0, 0x1c, 0x02,
    0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x0e, 0x30, 0x0c, 0x06,
    0x08, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x05, 0x00,
];

#[test]
fn test_parse_v2c_get_request() {
    let message = parse_message(RAW_PACKET).unwrap();

    assert_eq!(message.version, 1);
    assert_eq!(message.community, b"public");

    let pdu = message.pdu;
    assert_eq!(pdu.tag, Asn1Tag::GetRequest);
    assert_eq!(pdu.request_id, 1);
    assert_eq!(pdu.error_status, ErrorStatus::NoError);
    assert_eq!(pdu.error_index, 0);

    assert_eq!(pdu.varbinds.len(), 1);

    let varbind = &pdu.varbinds[0];
    let expected_oid: Vec<u32> = vec![1, 3, 6, 1, 2, 1, 1, 1, 0];
    assert_eq!(varbind.oid, expected_oid);

    assert_eq!(varbind.value, ObjectSyntax::Null);
}

const RAW_PACKET_RESPONSE: &[u8] = &[
    0x30, 0x42, 0x02, 0x01, 0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa2, 0x35, 0x02,
    0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x27, 0x30, 0x25, 0x06,
    0x08, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x04, 0x19, 0x53, 0x61, 0x6d, 0x70, 0x6c,
    0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
    0x74, 0x69, 0x6f, 0x6e,
];

#[test]
fn test_parse_v2c_get_response() {
    let message = parse_message(RAW_PACKET_RESPONSE).unwrap();

    assert_eq!(message.version, 1);
    assert_eq!(message.community, b"public");

    let pdu = message.pdu;
    assert_eq!(pdu.tag, Asn1Tag::GetResponse);
    assert_eq!(pdu.request_id, 1);
    assert_eq!(pdu.error_status, ErrorStatus::NoError);
    assert_eq!(pdu.error_index, 0);

    assert_eq!(pdu.varbinds.len(), 1);

    let varbind = &pdu.varbinds[0];
    let expected_oid: Vec<u32> = vec![1, 3, 6, 1, 2, 1, 1, 1, 0];
    assert_eq!(varbind.oid, expected_oid);

    let expected_value = b"Sample system description";
    match &varbind.value {
        ObjectSyntax::OctetString(val) => {
            assert_eq!(val, expected_value);
        }
        _ => panic!("Expected OctetString, got {:?}", varbind.value),
    }
}

#[test]
fn test_parse_real_snmpd_response() {
    // Full packet capture including Ethernet/IP/UDP headers
    let full_packet = &[
        0x2, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0xe2, 0xed, 0xe8, 0x0, 0x0, 0x40, 0x11, 0x0, 0x0, 0x7f,
        0x0, 0x0, 0x1, 0x7f, 0x0, 0x0, 0x1, 0x0, 0xa1, 0xfc, 0x86, 0x0, 0xce, 0xfe, 0xe1,
        0x30, // <- starts at 30 -> SEQ
        0x81, 0xc3, 0x2, 0x1, 0x1, 0x4, 0x6, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0xa2, 0x81, 0xb5,
        0x2, 0x4, 0x18, 0xec, 0xdb, 0x43, 0x2, 0x1, 0x0, 0x2, 0x1, 0x0, 0x30, 0x81, 0xa6, 0x30,
        0x81, 0xa3, 0x6, 0x8, 0x2b, 0x6, 0x1, 0x2, 0x1, 0x1, 0x1, 0x0, 0x4, 0x81, 0x96, 0x44, 0x61,
        0x72, 0x77, 0x69, 0x6e, 0x20, 0x4e, 0x61, 0x72, 0x65, 0x6e, 0x64, 0x72, 0x61, 0x73, 0x2d,
        0x4d, 0x61, 0x63, 0x42, 0x6f, 0x6f, 0x6b, 0x2d, 0x41, 0x69, 0x72, 0x2e, 0x6c, 0x6f, 0x63,
        0x61, 0x6c, 0x20, 0x32, 0x35, 0x2e, 0x30, 0x2e, 0x30, 0x20, 0x44, 0x61, 0x72, 0x77, 0x69,
        0x6e, 0x20, 0x4b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,
        0x6e, 0x20, 0x32, 0x35, 0x2e, 0x30, 0x2e, 0x30, 0x3a, 0x20, 0x57, 0x65, 0x64, 0x20, 0x53,
        0x65, 0x70, 0x20, 0x31, 0x37, 0x20, 0x32, 0x31, 0x3a, 0x34, 0x31, 0x3a, 0x33, 0x39, 0x20,
        0x50, 0x44, 0x54, 0x20, 0x32, 0x30, 0x32, 0x35, 0x3b, 0x20, 0x72, 0x6f, 0x6f, 0x74, 0x3a,
        0x78, 0x6e, 0x75, 0x2d, 0x31, 0x32, 0x33, 0x37, 0x37, 0x2e, 0x31, 0x2e, 0x39, 0x7e, 0x31,
        0x34, 0x31, 0x2f, 0x52, 0x45, 0x4c, 0x45, 0x41, 0x53, 0x45, 0x5f, 0x41, 0x52, 0x4d, 0x36,
        0x34, 0x5f, 0x54, 0x38, 0x31, 0x30, 0x33, 0x20, 0x61, 0x72, 0x6d, 0x36, 0x34,
    ];

    // SNMP data starts at offset 32 (after pcap + IP + UDP headers)
    // The SNMP message begins with 0x30 (Sequence tag)
    let snmp_offset = 32;
    let snmp_data = &full_packet[snmp_offset..];

    let msg = parse_message(snmp_data).expect("Failed to parse");

    println!("Version: {}", msg.version);
    println!("Community: {}", String::from_utf8_lossy(&msg.community));
    println!("PDU type: {:?}", msg.pdu.tag);
    println!("VarBinds: {}", msg.pdu.varbinds.len());
}


// to bytes 

#[test]
fn test_encode_v2c_get_request() {

let message = SnmpMessage {
        version: 1,
        community: b"public".to_vec(),
        pdu: Pdu {
            tag: Asn1Tag::GetRequest,
            request_id: 1,
            error_status: ErrorStatus::NoError,
            error_index: 0,
            varbinds: vec![VarBind {
                oid: vec![1, 3, 6, 1, 2, 1, 1, 1, 0],
                value: ObjectSyntax::Null,
            }],
        },
    };

    // 2. Encode our struct to our new, *minimal* bytes
    let encoded_bytes = message.to_bytes();

    // 3. (Optional) Let's check our new minimal bytes against the diff.
    //    Our encoded bytes are the "left" array from the panic.
    let our_minimal_bytes = vec![
        48, 38, 2, 1, 1, 4, 6, 112, 117, 98, 108, 105, 99, 160, 25, 2, 1, 1, 2, 1, 0, 2,
        1, 0, 48, 14, 48, 12, 6, 8, 43, 6, 1, 2, 1, 1, 1, 0, 5, 0,
    ];
    assert_eq!(encoded_bytes, our_minimal_bytes);

    // 4. THE REAL TEST: Parse our *own* encoded bytes back.
    //    If this works, our parser and encoder are perfectly compatible.
    let round_tripped_message = parse_message(&encoded_bytes).unwrap();

    // 5. Assert that the struct we got back is *identical*
    //    to the one we started with.
    assert_eq!(message, round_tripped_message);
}
